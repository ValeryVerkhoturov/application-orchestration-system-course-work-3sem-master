# Python Flask Application for Node 1
# Connects to PostgreSQL database
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: app-node1-code
  namespace: node1-services
data:
  app.py: |
    from flask import Flask, jsonify, request
    import psycopg2
    import os
    import logging
    from datetime import datetime
    import socket

    app = Flask(__name__)
    logging.basicConfig(level=logging.INFO)
    logger = logging.getLogger(__name__)

    def get_db_connection():
        """Create database connection"""
        try:
            conn = psycopg2.connect(
                host=os.environ.get('DB_HOST', 'postgres-node1'),
                port=os.environ.get('DB_PORT', '5432'),
                database=os.environ.get('DB_NAME', 'node1_db'),
                user=os.environ.get('DB_USER', 'app_user'),
                password=os.environ.get('DB_PASSWORD', 'PLACEHOLDER_FROM_VAULT')
            )
            return conn
        except Exception as e:
            logger.error(f"Database connection error: {e}")
            raise

    def init_db():
        """Initialize database tables"""
        try:
            conn = get_db_connection()
            cur = conn.cursor()
            cur.execute('''
                CREATE TABLE IF NOT EXISTS items (
                    id SERIAL PRIMARY KEY,
                    name VARCHAR(255) NOT NULL,
                    description TEXT,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    node_id VARCHAR(50) DEFAULT 'node1'
                )
            ''')
            cur.execute('''
                CREATE TABLE IF NOT EXISTS health_checks (
                    id SERIAL PRIMARY KEY,
                    hostname VARCHAR(255),
                    check_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    status VARCHAR(50)
                )
            ''')
            conn.commit()
            cur.close()
            conn.close()
            logger.info("Database initialized successfully")
        except Exception as e:
            logger.error(f"Database initialization error: {e}")

    @app.route('/')
    def index():
        """Root endpoint"""
        return jsonify({
            'service': 'Node 1 Python App',
            'version': '1.0.0',
            'hostname': socket.gethostname(),
            'timestamp': datetime.now().isoformat()
        })

    @app.route('/health')
    def health():
        """Health check endpoint"""
        try:
            conn = get_db_connection()
            cur = conn.cursor()
            cur.execute('SELECT 1')
            cur.close()
            conn.close()
            return jsonify({
                'status': 'healthy',
                'database': 'connected',
                'hostname': socket.gethostname(),
                'timestamp': datetime.now().isoformat()
            })
        except Exception as e:
            return jsonify({
                'status': 'unhealthy',
                'database': 'disconnected',
                'error': str(e),
                'hostname': socket.gethostname()
            }), 500

    @app.route('/ready')
    def ready():
        """Readiness check"""
        try:
            conn = get_db_connection()
            cur = conn.cursor()
            cur.execute('SELECT 1')
            cur.close()
            conn.close()
            return jsonify({'ready': True})
        except:
            return jsonify({'ready': False}), 503

    @app.route('/items', methods=['GET'])
    def get_items():
        """Get all items"""
        try:
            conn = get_db_connection()
            cur = conn.cursor()
            cur.execute('SELECT id, name, description, created_at, node_id FROM items ORDER BY created_at DESC')
            items = cur.fetchall()
            cur.close()
            conn.close()
            return jsonify({
                'items': [
                    {
                        'id': row[0],
                        'name': row[1],
                        'description': row[2],
                        'created_at': row[3].isoformat() if row[3] else None,
                        'node_id': row[4]
                    } for row in items
                ],
                'count': len(items)
            })
        except Exception as e:
            return jsonify({'error': str(e)}), 500

    @app.route('/items', methods=['POST'])
    def create_item():
        """Create new item"""
        try:
            data = request.get_json()
            name = data.get('name')
            description = data.get('description', '')
            
            if not name:
                return jsonify({'error': 'Name is required'}), 400
            
            conn = get_db_connection()
            cur = conn.cursor()
            cur.execute(
                'INSERT INTO items (name, description, node_id) VALUES (%s, %s, %s) RETURNING id',
                (name, description, 'node1')
            )
            item_id = cur.fetchone()[0]
            conn.commit()
            cur.close()
            conn.close()
            
            logger.info(f"Created item {item_id}: {name}")
            return jsonify({
                'id': item_id,
                'name': name,
                'description': description,
                'node_id': 'node1',
                'message': 'Item created successfully'
            }), 201
        except Exception as e:
            return jsonify({'error': str(e)}), 500

    @app.route('/items/<int:item_id>', methods=['DELETE'])
    def delete_item(item_id):
        """Delete item"""
        try:
            conn = get_db_connection()
            cur = conn.cursor()
            cur.execute('DELETE FROM items WHERE id = %s RETURNING id', (item_id,))
            deleted = cur.fetchone()
            conn.commit()
            cur.close()
            conn.close()
            
            if deleted:
                return jsonify({'message': f'Item {item_id} deleted'})
            return jsonify({'error': 'Item not found'}), 404
        except Exception as e:
            return jsonify({'error': str(e)}), 500

    @app.route('/db/stats')
    def db_stats():
        """Database statistics"""
        try:
            conn = get_db_connection()
            cur = conn.cursor()
            cur.execute('SELECT COUNT(*) FROM items')
            item_count = cur.fetchone()[0]
            cur.execute('SELECT version()')
            pg_version = cur.fetchone()[0]
            cur.close()
            conn.close()
            
            return jsonify({
                'items_count': item_count,
                'postgres_version': pg_version,
                'node': 'node1',
                'hostname': socket.gethostname()
            })
        except Exception as e:
            return jsonify({'error': str(e)}), 500

    # Initialize database on module load (works with Gunicorn)
    with app.app_context():
        import time
        max_retries = 10
        for i in range(max_retries):
            try:
                init_db()
                logger.info("Database initialization complete")
                break
            except Exception as e:
                logger.warning(f"DB init attempt {i+1}/{max_retries} failed: {e}")
                if i < max_retries - 1:
                    time.sleep(3)
                else:
                    logger.error("Failed to initialize database after all retries")

    if __name__ == '__main__':
        app.run(host='0.0.0.0', port=5000, debug=False)

  requirements.txt: |
    flask==3.0.0
    psycopg2-binary==2.9.9
    gunicorn==21.2.0
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: postgres-node1-config
  namespace: node1-services
data:
  POSTGRES_DB: "node1_db"
  POSTGRES_USER: "app_user"
  PGDATA: "/var/lib/postgresql/data/pgdata"
---
apiVersion: v1
kind: Secret
metadata:
  name: postgres-node1-secret
  namespace: node1-services
type: Opaque
stringData:
  POSTGRES_PASSWORD: "SecurePass123_Node1"
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: postgres-node1-pvc
  namespace: node1-services
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 5Gi
---
# PostgreSQL Database for Node 1
apiVersion: apps/v1
kind: Deployment
metadata:
  name: postgres-node1
  namespace: node1-services
  labels:
    app: postgres
    node: node1
    tier: database
spec:
  replicas: 1
  strategy:
    type: Recreate
  selector:
    matchLabels:
      app: postgres
      node: node1
  template:
    metadata:
      labels:
        app: postgres
        node: node1
        tier: database
    spec:
      nodeSelector:
        worker-id: node1
      restartPolicy: Always
      containers:
        - name: postgres
          image: postgres:15-alpine
          ports:
            - containerPort: 5432
              name: postgres
          envFrom:
            - configMapRef:
                name: postgres-node1-config
            - secretRef:
                name: postgres-node1-secret
          volumeMounts:
            - name: postgres-storage
              mountPath: /var/lib/postgresql/data
          resources:
            requests:
              memory: "256Mi"
              cpu: "250m"
            limits:
              memory: "512Mi"
              cpu: "500m"
          livenessProbe:
            exec:
              command:
                - pg_isready
                - -U
                - app_user
                - -d
                - node1_db
            initialDelaySeconds: 30
            periodSeconds: 10
            timeoutSeconds: 5
            failureThreshold: 3
          readinessProbe:
            exec:
              command:
                - pg_isready
                - -U
                - app_user
                - -d
                - node1_db
            initialDelaySeconds: 5
            periodSeconds: 5
            timeoutSeconds: 3
            failureThreshold: 3
      volumes:
        - name: postgres-storage
          persistentVolumeClaim:
            claimName: postgres-node1-pvc
---
apiVersion: v1
kind: Service
metadata:
  name: postgres-node1
  namespace: node1-services
  labels:
    app: postgres
    node: node1
spec:
  type: ClusterIP
  ports:
    - port: 5432
      targetPort: 5432
      name: postgres
  selector:
    app: postgres
    node: node1
---
# Python Flask Application Deployment for Node 1
apiVersion: apps/v1
kind: Deployment
metadata:
  name: python-app-node1
  namespace: node1-services
  labels:
    app: python-app
    node: node1
    tier: backend
spec:
  replicas: 2
  strategy:
    type: Recreate
  selector:
    matchLabels:
      app: python-app
      node: node1
  template:
    metadata:
      labels:
        app: python-app
        node: node1
        tier: backend
    spec:
      nodeSelector:
        worker-id: node1
      restartPolicy: Always
      initContainers:
        - name: wait-for-postgres
          image: busybox:1.36
          command: ['sh', '-c', 'until nc -z postgres-node1 5432; do echo waiting for postgres; sleep 2; done; echo postgres is ready']
      containers:
        - name: python-app
          image: python:3.11-slim
          command: ["/bin/sh", "-c"]
          args:
            - |
              pip install --no-cache-dir -r /app/requirements.txt &&
              cd /app &&
              gunicorn --bind 0.0.0.0:5000 --workers 2 --threads 4 --access-logfile - --error-logfile - app:app
          ports:
            - containerPort: 5000
              name: http
          env:
            - name: DB_HOST
              value: "postgres-node1"
            - name: DB_PORT
              value: "5432"
            - name: DB_NAME
              valueFrom:
                configMapKeyRef:
                  name: postgres-node1-config
                  key: POSTGRES_DB
            - name: DB_USER
              valueFrom:
                configMapKeyRef:
                  name: postgres-node1-config
                  key: POSTGRES_USER
            - name: DB_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: postgres-node1-secret
                  key: POSTGRES_PASSWORD
          volumeMounts:
            - name: app-code
              mountPath: /app
          resources:
            requests:
              memory: "128Mi"
              cpu: "100m"
            limits:
              memory: "256Mi"
              cpu: "300m"
          livenessProbe:
            httpGet:
              path: /health
              port: 5000
            initialDelaySeconds: 60
            periodSeconds: 10
            timeoutSeconds: 5
            failureThreshold: 3
          readinessProbe:
            httpGet:
              path: /ready
              port: 5000
            initialDelaySeconds: 30
            periodSeconds: 5
            timeoutSeconds: 3
            failureThreshold: 3
      volumes:
        - name: app-code
          configMap:
            name: app-node1-code
---
apiVersion: v1
kind: Service
metadata:
  name: python-app-node1
  namespace: node1-services
spec:
  type: ClusterIP
  ports:
    - port: 5000
      targetPort: 5000
      name: http
  selector:
    app: python-app
    node: node1
---
# NodePort Service for external access
apiVersion: v1
kind: Service
metadata:
  name: python-app-node1-external
  namespace: node1-services
spec:
  type: NodePort
  ports:
    - port: 5000
      targetPort: 5000
      nodePort: 30501
      name: http
  selector:
    app: python-app
    node: node1